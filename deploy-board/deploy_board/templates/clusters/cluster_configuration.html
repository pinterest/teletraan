{% extends 'environs/env_base.html'%} {% load utils %} {% block breadcrumb-items %}
<ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/envs">Environments</a></li>
    <li><a href="/env/{{ env.envName }}/{{ env.stageName }}">{{ env.envName }} ({{ env.stageName }})</a></li>
    <li><a href="/env/{{ env.envName }}/{{ env.stageName }}/config">General Config</a></li>
    <li><a href="/env/{{ env.envName }}/{{ env.stageName }}/config/capacity">Capacity</a></li>
    <li class="active">Cluster Configuration</li>
</ul>
{% endblock %} {% load static %} {% block side-panel-actions %}
<link rel="stylesheet" href="//cdn.jsdelivr.net/chartist.js/latest/chartist.min.css">
<style>
    .ct-series-a .ct-bar {
        stroke: #2a7b86;
    }

    .ct-chart table td {
        text-align: center;
    }
</style>
<script type="text/javascript" src="//cdn.jsdelivr.net/chartist.js/latest/chartist.min.js"></script>
<script type="text/javascript" src="{% static "js/components/sharedcomponents.js"%}?changedate=2016.12.19.150000"></script>
<script type="text/javascript" src="{% static "js/components/capacitycomponents.js"%}?changedate=2017.07.05.180000"></script>
<script type="text/javascript" src="{% static "js/components/clusterconfigcomponents.js"%}?changedate=2018.05.17.153000"></script>

<div class="panel panel-default" id="side-panel">
    <div class="panel-heading clearfix">
        <h4 class="panel-title pull-left">Capacity</h4>
    </div>
    <div v-if="noCluster" class="row">
        <side-button styleclass="fa fa-cloud" text="Create New Capacity" href="/env/{{ env.envName }}/{{ env.stageName }}/config/newcapacity/" title="Create New Cluster"></side-button>
    </div>
    <div v-if="!noCluster" class="row">
        <side-button-nolink styleclass="fa fa-gears" v-on:click="buttonClick" v-bind:text="settingText" title="Cluster Configuration"></side-button-nolink>
    </div>
    <div v-if="!noCluster" class="row">
        <side-button styleclass="glyphicon glyphicon-time" text="Replacement History" href="/env/{{ env.envName }}/{{ env.stageName }}/replacement" title="Replacement History"></side-button>
    </div>
    <replace-cluster v-bind:clusterstate="clusterState" v-on:input="clusterAction"></replace-cluster>
</div>
{% endblock %} {% block new-builds-panel %} {% endblock %} {% block new-pred-deploys-panel %} {% endblock %} {% block main %}

<div id="clusterAlert">
    <in-rolling-alert v-show="showReplaceAlert" actionlink="/env/{{ env.envName }}/{{ env.stageName }}/config/cluster/config/"></in-rolling-alert>
</div>
{% include "environs/env_tabs.tmpl" with envTabKind="config/capacity" %}


<div id="mainPanel" class="panel panel-default">
    <panel-heading title="Cluster Settings" target="#envCapacityId" initcollapse="false"></panel-heading>
    <div id="envCapacityId" class="collapse in panel-body" v-on:show.bs.collapse="showcontent" v-on:hide.bs.collapse="hidecontent">
        <div class="container-fluid">
            <form id="clusterConfigFormId" class="form-horizontal" role="form">
                <fieldset id="clusterConfigFieldSetId">
                    <cloudprovider-select v-bind:cloudproviders="providers" v-bind:value="currentProvider" v-show="inAdvanced"></cloudprovider-select>
                    <cell-select v-bind:cells="cells" v-on:cellchange="cellChange"  v-bind:value="currentCell"></cell-select>
                    <baseimage-select v-show="inAdvanced" v-bind:imagenames="imagenames" v-bind:baseimages="baseimages" v-bind:imagenamevalue="imageNameValue" v-bind:baseImageValue="baseImageValue"
                    v-on:baseimagechange="baseImageChange" v-on:imagenamechange="imageNameChange" v-bind:inadvanced="inAdvanced" showhelp="true" v-on:helpclick="baseImageHelpClick">
                    </baseimage-select>
                    <base-image-help v-show="showBaseImageHelp" v-bind:data="baseImageHelpData"></base-image-help>
                    <label-select label="Host Type" title="Compute Capability of the host" v-model="selectedHostTypeValue" v-bind:selectoptions="hostTypeOptions"
                        v-on:input="updateImageNameForEbsHost" showhelp="true" v-on:helpclick="hostTypeHelpClick"></label-select>
                    <hostype-help v-show="showHostTypeHelp" v-bind:data="hostTypeHelpData"></hostype-help>
                    <label-select label="Security Zone" title="Security zone to control inbound/outboud traffic" v-model="selectedSecurityZoneValue" v-bind:selectoptions="securityZones"
                    showhelp="true" v-on:helpclick="securityZoneHelpClick"></label-select>
                    <securityzone-help v-show="showSecurityZoneHelp" v-bind:data="securityZoneHelpData"></securityzone-help>
                    <placements-select label="Placements" title="Placements" v-bind:selectoptions="placements" v-bind:assignpublicip="assignPublicIP"
                    showhelp="true" v-on:helpclick="placementsHelpClick" v-on:assignpublicipclick="selectpublicip"></placements-select>
                    <placements-help v-show="showPlacementsHelp" v-bind:data="placementsHelpData"></placements-help>
                    <div v-if="inAdvanced">
                        <div class="form-group"></div>
                        <div class="form-group">
                            <label class="deployToolTip control-label col-xs-2" data-toggle="tooltip"  title="Customize user data">User data configs:</label>
                            {% if is_pinterest %}
                                <a href={{user_data_config_settings_wiki}} target="_blank"><span class="glyphicon glyphicon-question-sign"></span></a>
                            {% endif %}
                            <div class="pull-right">
                                <add-config-button target="#newConfigModalId"></add-config-button>
                                <aws-config-modal id="newConfigModalId" v-bind:options="availableConfigOptions()" v-on:click="addConfig"></aws-config-modal>
                            </div>
                        </div>
                        <aws-user-data v-bind:alluserdata="allUserData" v-on:deleteconfig="deleteConfig" v-on:change="configChange" v-bind:inadvanced="inAdvanced" v-bind:showcmpgroup="showCmpGroup"></aws-user-data>
                    </div>
                </fieldset>
            </form>
        </div>
    </div>
    <modal v-bind:title="confirmDialogTitle" v-bind:id="confirmDialogId" v-on:input="clickDialog">
        <div slot="body">Are you sure to save the changes?</div>
    </modal>

    <div class="panel-footer clearfix">
        <div class="pull-right">
            <button id="saveEnvCapacityBtnId" class="btn btn-primary" v-bind:disabled="!canSaveCapacity" data-target="#updateClusterSettings" data-toggle="modal" data-loading-text="Creating...">
            <span class="glyphicon glyphicon-floppy-save"></span> Save
        </button>
        </div>
    </div>
</div>

<div id="replaceProgressPanel" v-show="show" class="panel panel-default">
    <div class="panel-heading clearfix">
        <h4 class="panel-title pull-left pointer-cursor">
            <a data-toggle="collapse" data-target="#activeClusterReplaceId">
                <span class="glyphicon glyphicon-chevron-down"></span>
                <span v-if="state == 'REPLACE'">Active Replacement</span>
                <span v-if="state == 'PAUSE'">Active Replacement (Paused)</span>
            </a>
        </h4>
    </div>
    <div id="activeClusterReplaceId" class="collapse in panel-body">
        {% include "clusters/replace_progress.tmpl" %}
    </div>
</div>

<div id="activeClusterReplaceGraph" v-show="show" class="panel panel-default">
    <div class="panel-heading clearfix">
        <h4 class="panel-title pull-left pointer-cursor">
            <a data-toggle="collapse" data-target="#activeClusterReplaceGraph">
                <span class="glyphicon glyphicon-chevron-down"></span>
                <span>Host Activities During Replacement</span>
            </a>
        </h4>
    </div>
    <div class="ct-chart"></div>
    <div id="tooltip" class="alert alert-info" style="display:none; top: 10px; right:20px;"></div>
</div>
<script>
/**
 * Chartist.js plugin that generates visually hidden tables for better accessibility. It's also possible to initialize a Chart with data from an existing table.
 *
 */
/* global Chartist */
(function (window, document, Chartist) {
  'use strict';

  // A simple recursive DOM string builder
  function Element(name, attrs, parent) {
    return {
      elem: function (name, attrs) {
        var e = Element(name, attrs, this);
        this.children.push(e);
        return e;
      },
      children: [],
      name: name,
      _attrs: attrs || {},
      _parent: parent,
      parent: function () {
        return this._parent;
      },
      attrs: function (attrs) {
        this._attrs = attrs;
        return this;
      },
      text: function (text, after) {
        if (after) {
          this._textAfter = text;
        } else {
          this._textBefore = text;
        }
        return this;
      },
      toString: function () {
        var attrs = Object.keys(this._attrs).filter(function (attrName) {
          return this._attrs[attrName] || this._attrs[attrName] === 0;
        }.bind(this)).map(function (attrName) {
          return [attrName, '="', this._attrs[attrName], '"'].join('');
        }.bind(this)).join(' ');

        return ['<', this.name, attrs ? ' ' + attrs : '', '>', this._textBefore].concat(this.children.map(function (child) {
          return child.toString();
        })).concat([this._textAfter, '</', this.name, '>']).join('');
      }
    };
  }

  var defaultOptions = {
    caption: 'A graphical chart',
    seriesHeader: 'Series name',
    valueTransform: Chartist.noop,
    summary: undefined,
    elementId: function () {
      return 'ct-accessibility-table';
    },
    visuallyHiddenStyles: 'position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden;'
  };

  Chartist.plugins = Chartist.plugins || {};

  Chartist.plugins.ctAccessibility = function (options) {
      $('#ct-accessibility-table').remove();

    options = Chartist.extend({}, defaultOptions, options);

    return function ctAccessibility(chart) {
      var elementId = typeof options.elementId === 'function' ? options.elementId() : options.elementId;

      chart.on('created', function (data) {
        var containerElement = data.svg._node.parentNode;

        var previousElement = containerElement.querySelector('#' + elementId);
        if(previousElement) {
          containerElement.removeChild(previousElement);
        }

        // As we are now compensating the SVG graphic with the chart with an accessibility table, we hide it for ARIA
        data.svg.attr({
          'aria-hidden': 'true'
        });

        // Create wrapper element
        var element = Element('div', {
          style: options.visuallyHiddenStyles,
          id: elementId
        });

        // Create table body with caption
        var tBody = element.elem('table', {
          class: 'table table-striped table-condensed table-hover',
          summary: options.summary
        }).elem('tbody');

        var firstRow = tBody.elem('tr');

        if (chart instanceof Chartist.Pie) {
          // For pie charts we have only column headers and one series
          var dataArray = Chartist.getDataArray(chart.data, chart.optionsProvider.getCurrentOptions().reverseData);

          // First render the column headers with our pie chart labels
          chart.data.labels.forEach(function (text) {
            firstRow
              .elem('th', {
                scope: 'col',
                role: 'columnheader'
              })
              .text(text);
          });

          var row = tBody.elem('tr');

          // Add all data fields of our pie chart to the row
          dataArray.forEach(function (dataValue) {
            row.elem('td').text(options.valueTransform(dataValue));
          });

        } else {
          // For line and bar charts we have multiple series and therefore also row headers
         // var normalizedData = Chartist.getDataArray(chart.data, chart.optionsProvider.getCurrentOptions().reverseData);
         var normalizedData = chart.data.series;


          // Add column headers inclusing the series column header for the row headers
          [options.seriesHeader].concat(chart.data.labels).forEach(function (text) {
            firstRow
              .elem('th', {
                scope: 'col',
                role: 'columnheader'
              })
              .text(text);
          });

          // Add all data rows including their row headers
          chart.data.series.forEach(function (series, index) {
            var seriesName = series.name || [index + 1, '. Series'].join('');

            var row = tBody.elem('tr');

            row.elem('th', {
              scope: 'row',
              role: 'rowheader'
            }).text(seriesName);

            normalizedData[index].data.forEach(function (dataValue) {
              row.elem('td').text(options.valueTransform(dataValue));
            });
          });
        }

        // Update invisible table in DOM and update table element with newly created table
        containerElement.appendChild(new DOMParser().parseFromString(element.toString(), 'text/html').getElementById(elementId));
      });
    };
  };

}(window, document, Chartist));


    function timeConverter(UNIX_timestamp) {
        var a = new Date(UNIX_timestamp);
        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        var month = months[a.getMonth()];
        var date = a.getDate();
        var hour = a.getHours();
        var min = a.getMinutes();
        if (min < 10) {
            min = '0' + min;
        }
        if (hour < 10) {
            hour = '0' + hour;
        }
        var time = month + ' ' + date + ', ' + hour + ':' + min;
        return time;
    }

    function normalizeGraphData(activities) {
        var times = {};
        for (var i = activities.length - 1; i >= 0; i--) {
            var scalingTime = activities[i]['scalingTime'];
            if (!times[scalingTime]) {
                times[scalingTime] = [];
            }
            times[scalingTime].push(activities[i]);
        }
        var labels = [], series1 = [], series2 = [];
        for (var time in times) {
            if (times.hasOwnProperty(time)) {
                var isLaunching = false;
                var events = times[time];
                var descriptions = [], event, description;
                var causes = [], cause;
                for (var j = 0; j < events.length; j++) {
                    event = events[j];
                    description = event['description'];
                    cause = event['cause'];
                    causes.push(cause);
                    descriptions.push(description);
                    if (description.indexOf('Launching') >= 0) {
                        isLaunching = true;
                    }
                }
                labels.push(timeConverter(parseInt(time)));
                var tooltip = descriptions.join('<br/>');
                var causeTooltip = causes.join('');
                if (isLaunching) {
                    series1.push({name: tooltip, meta: causeTooltip, value: events.length });
                    series2.push({name: '', meta: '', value: 0 });
                } else {
                    series1.push({name: '', meta: '', value: 0 });
                    series2.push({name: tooltip, meta: causeTooltip, value: events.length });
                }

            }
        }
        return [labels, [series1, series2]];
    }


    function accessibility(labels, series1, series2) {
        var width = 50 * labels.length;
        var chart = new Chartist.Bar('.ct-chart', {
                labels: labels,
                series: [
                    {name: '# hosts launched', data: series1},
                    {name: '# hosts terminated', data: series2}
                ]
            },
            {

                lineSmooth: false,
                chartPadding: {
                    right: 20,
                    left: 10
                },
                width: width,
                height: 200,
                axisX: {
                    labelInterpolationFnc: function (value) {
                        return value;
                    }
                },
                axisY: {
                    onlyInteger: true,
                    label: '# of hosts launched/terminated'
                },
                plugins: [
                    Chartist.plugins.ctAccessibility({
                        seriesHeader: 'timeline',
                        valueTransform: function (data) {
                            return data.name;
                        },
                        visuallyHiddenStyles: 'width: 70%; font-size: 11px; overflow-x: auto; background-color: rgba(0, 0, 0, 0.1); padding: 15px;'
                    })
                ]
            });

        var addedEvents = false;
        chart.on('draw', function() {
          if (!addedEvents) {
            $('.ct-chart').on('mouseover', function(event) {
                var $point = event.target;
                var meta = $point.getAttribute('ct:meta')|| '';
                var tips = meta.split('.').filter(function (v) {
                    return v.trim() != '';
                });
                if(tips.length > 0) {
                    var tooltip = '<ul><li>' + tips.join('.</li><li>') + '</li></ul>';
                    $('#tooltip').html(tooltip);
                    $('#tooltip').show();
                }
            });

            $('.ct-chart').on('mouseout', function() {
                  $('#tooltip').hide();
            });
          }
        });

    }
</script>
<script>
    var info = {{capacity_creation_info | safe}};
    var env = info.environment;
    var currentCluster = info.currentCluster;
    if (currentCluster!=null){
        var currentPlacements = currentCluster.placement.split(',');
        var placements = getDefaultPlacement(info);
        var showReplaceAlert = currentCluster != null && currentCluster.state != "NORMAL";
        var alert = new Vue({
            el: "#clusterAlert",
            data: {
                showReplaceAlert: showReplaceAlert
            }
        });

        var sorted = info.baseImages.sort(function(item1, item2) {
            return item2.publish_date - item1.publish_date;
        });

        var capacitySetting = new Vue({
            el: "#mainPanel",
            data: {
                allUserData:  Object.keys(currentCluster.configs).map(
                        function(key) {
                            return {
                                name: key,
                                value: currentCluster.configs[key],
                                readonly: key === 'spiffe_id'
                            }
                        }).filter(function(item){return item.name!='assign_public_ip'}),
                spiffeId: 'spiffe_id' in currentCluster.configs ? currentCluster.configs['spiffe_id']:null,
                assignPublicIP: currentCluster.configs.assign_public_ip == "true" ? true : false,
                awsRole: currentCluster.configs.aws_role,
                baseimages: info.baseImages.map(function(o) {
                    var acceptance = o.acceptance ? ' [' + o.acceptance + ']' : '';
                    return {
                        value: o.id,
                        text: o.provider_name + acceptance,
                        isSelected: o.id === currentCluster.baseImageId
                    }
                }),
                baseImageValue: currentCluster.baseImageId,
                confirmDialogTitle: "Update Cluster Settings",
                confirmDialogId: "updateClusterSettings",
                currentProvider: currentCluster.provider,
                currentCell: currentCluster.cellName,
                hostTypeOptions: info.hostTypes.map(function(item, idx) {
                    return {
                        value: item.id,
                        text: item.abstract_name + " (" + item.core + " cores, " + item.mem + " GB, " + item.storage + ", " + item.provider + ": " + item.provider_name + ")",
                        isSelected: item.abstract_name === currentCluster.hostType
                    }
                }),
                imageNameValue: currentCluster.baseImageName,
                imagenames: info.baseImageNames.map(function(o) {
                    return {
                        value: o,
                        text: o,
                        isSelected: o === currentCluster.baseImageName
                    }
                }),
                inAdvanced: false,
                placements: this.inAdvanced ?
                    placements.getFullList(currentCluster.configs.assign_public_ip, currentPlacements) :
                    placements.getSimpleList(currentCluster.configs.assign_public_ip, currentPlacements),
                providers: info.providerList.map(function(o) {
                    return {
                        value: o,
                        text: o
                    }
                }),
                cells: info.cells.map(
                    function (item) {
                        return {
                            value: item.name,
                            text: item.name,
                            isSelected: item.name == currentCluster.cellName
                        }
                    }),
                securityZones: info.securityZones.map(function(item) {
                    return {
                        value: item.abstract_name,
                        text: item.abstract_name,
                        isSelected: item.abstract_name === currentCluster.securityZone
                    }
                }),
                selectedHostTypeValue: capacityCreationInfo.hostTypes.find(hostType => hostType.abstract_name === currentCluster.hostType).id,
                selectedSecurityZoneValue: currentCluster.securityZone,
                selectedPlacements: currentPlacements,
                showBaseImageHelp: false,
                baseImageHelpData: [],
                showHostTypeHelp: false,
                hostTypeHelpData:[],
                showSecurityZoneHelp: false,
                securityZoneHelpData: [],
                showPlacementsHelp: false,
                placementsHelpData: [],
                canSaveCapacity: !showReplaceAlert,
                showCmpGroup: Boolean(getUrlParameter("showcmpgroup"))
            },
            methods: {
                addConfig: function(config) {
                    var filter = this.allUserData.filter(function(data) {
                        return data.name === config.name
                    })
                    if (filter.length == 0) {
                        this.allUserData.push(config)
                    } else {
                        filter[0].value = config.value
                    }
                },
                availableConfigOptions: function() {
                    var options = Object.keys(info.configList).map(function(key) {
                        return {
                            name: key,
                            text: key,
                            default: info.configList[key]
                        }
                    }).filter(function(item){return item.name!='assign_public_ip'})
                    if (this.inAdvanced){
                        return options;
                    }
                    else{
                        return options.filter(function(item){return !item.name.startsWith("pinfo_") && item.name!="cmp_group" });
                    }
                },
                configChange: function(input){
                    this.allUserData = this.allUserData.map(function(item){
                        if (item.name===input.name){
                            return input
                        }
                        else{
                            return item
                        }
                    })
                },
                baseImageHelpClick: function(){
                    if (this.showBaseImageHelp){
                        this.showBaseImageHelp = false;
                    }
                    else{
                        this.getHelpInfo('get_base_image_info/' + this.imageNameValue, function(data){
                            data = data.map(function(item){
                                item.publish_date=new Date(item.publish_date)
                                if (item.description == null || item.description.length==0){
                                    item.description = "None"
                                }
                                return item
                            })
                            capacitySetting.baseImageHelpData = data
                            capacitySetting.showBaseImageHelp = true
                        })
                    }
                },
                baseImageChange: function(value) {
                    this.baseImageValue = value
                },
                deleteConfig: function(name) {
                    this.allUserData = this.allUserData.filter(function(config) {
                        return config.name != name
                    })
                },
                getHelpInfo: function(path, onSuccess){
                        $.ajax({
                            type: 'GET',
                            url: location.protocol + '//' + location.host + '/clouds/'+path+'/',
                            dataType: "json",
                            beforeSend: function(xhr, settings) {
                                var csrftoken = getCookie('csrftoken')
                                xhr.setRequestHeader("X-CSRFToken", csrftoken);

                            },
                            success: function(data){
                                onSuccess(data)
                            },
                            error: function(data) {
                                globalNotificationBanner.error = ["Request Error: ", data.status, data.statusText, data.responseText].join(' ');
                            }
                        });
                },
                hostTypeHelpClick: function(){
                    if (this.showHostTypeHelp){
                        this.showHostTypeHelp = false;
                    }
                    else{
                        this.getHelpInfo('get_host_type_info', function(data){
                                capacitySetting.hostTypeHelpData = data
                                capacitySetting.showHostTypeHelp = true
                        })
                    }
                },
                cellChange: function(value) {
                    capacitySetting.cellValue = value;
                    capacitySetting.currentCell = value;
                    // grab all the image names
                    var scope = this;
                    var provider = capacitySetting.currentProvider;
                    var cell = value;
                    $.ajax({
                        type: 'GET',
                        url: location.protocol + '//' + location.host + '/clouds/image_names/' + provider + '/' + cell,
                        dataType: "json",
                        beforeSend: function (xhr) {
                            var csrftoken = getCookie('csrftoken');
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);
                        },
                        success: function (data) {
                            capacitySetting.imagenames = data.map(
                                    function (o) {
                                        return {
                                            value: o,
                                            text: o, isSelected: o === data[0]
                                        }
                                    });
                            capacitySetting.imageNameValue = data[0];
                            scope.imageNameChange(data[0]);
                        },
                        error: function (data) {
                            globalNotificationBanner.error = data
                        }
                    });

                     // grab all security zone for this cell
            $.ajax({
                type: 'GET',
                url: location.protocol + '//' + location.host + '/clouds/securityzones/' + provider + '/' + cell,
                dataType: "json",
                beforeSend: function (xhr) {
                    var csrftoken = getCookie('csrftoken');
                    xhr.setRequestHeader("X-CSRFToken", csrftoken);
                },
                success: function (data) {
                    capacitySetting.securityZones = data.map(
                        function (item) {
                            return {
                                value: item.abstract_name,
                                text: item.abstract_name,
                                isSelected: item.id === data[0].id
                            }
                        });
                    capacitySetting.selectedSecurityZoneValue = data[0].abstract_name;
                },
                error: function (data) {
                    globalNotificationBanner.error = data
                }
            });
            // grab all placement for this cell
            $.ajax({
                type: 'GET',
                url: location.protocol + '//' + location.host + '/clouds/placements/' + provider + '/' + cell,
                dataType: "json",
                beforeSend: function (xhr) {
                    var csrftoken = getCookie('csrftoken');
                    xhr.setRequestHeader("X-CSRFToken", csrftoken);
                },
                success: function (data) {
                    var placements = getDefaultPlacement({'placements': data});

                    capacitySetting.placements =  placements.allPrivate.map(
                        function (item, index) {
                            return {
                                value: item.id,
                                text: item.provider_name,
                                isSelected: index < 3 //Select Top 3 by default
                            }
                        });
                },
                error: function (data) {
                    globalNotificationBanner.error = data
                }
            })

                },
                imageNameChange: function(value) {
                    var cell = capacitySetting.currentCell;
                    capacitySetting.imageNameValue = value;
                    //Grab all images for this image name
                    $.ajax({
                        type: 'GET',
                        url: location.protocol + '//' + location.host + '/clouds/get_base_images/' + value + '?cell=' + cell,
                        dataType: "json",
                        beforeSend: function(xhr, settings) {
                            var csrftoken = getCookie('csrftoken')
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);

                        },
                        success: function(data) {
                            sorted = data.sort(function(item1, item2) {
                                return item2.publish_date - item1.publish_date;
                            })
                            capacitySetting.baseimages = sorted.map(function(o) {
                                var acceptance = o.acceptance ? ' [' + o.acceptance + ']' : '';
                                return {
                                    value: o.id,
                                    text: o.provider_name + acceptance
                                }
                            })
                            capacitySetting.baseImageValue = sorted[0].id
                        },
                        error: function(data) {
                            globalNotificationBanner.error = data
                        }
                    });
                },
                updateImageNameForEbsHost: function () {
                    var cell = capacitySetting.currentCell;
                    var scope = this;
                    var provider = capacitySetting.currentProvider;
                    value = 'cmp_base-ebs';
                    const selectedHostTypeObject = capacityCreationInfo.hostTypes.find(hostType => hostType.id === this.selectedHostTypeValue);
                    if (selectedHostTypeObject.abstract_name.startsWith('EbsCompute')) {
                        capacitySetting.imageNameValue = value;
                        capacitySetting.imagenames = info.baseImageNames.map(
                            function (o) {
                                return {
                                    value: o,
                                    text: o,
                                    isSelected: o === value
                                }
                            }),
                            scope.imageNameChange(value);

                        //Grab all images for this image name
                        $.ajax({
                            type: 'GET',
                            url: location.protocol + '//' + location.host + '/clouds/get_base_images/' + value + '?cell=' + cell,
                            dataType: "json",
                            beforeSend: function (xhr, settings) {
                                var csrftoken = getCookie('csrftoken')
                                xhr.setRequestHeader("X-CSRFToken", csrftoken);

                            },
                            success: function (data) {
                                sorted = data.sort(function (item1, item2) { return item2.publish_date - item1.publish_date; })
                                capacitySetting.baseimages = sorted.map(function (o) { return { value: o.id, text: o.provider_name } })
                                capacitySetting.baseImageValue = sorted[0].id
                            },
                            error: function (data) {
                                globalNotificationBanner.error = data
                            }
                        });
                    }
                },
                placementsHelpClick: function(){
                    if (this.showPlacementsHelp){
                        this.showPlacementsHelp = false
                    }
                    else{
                        this.getHelpInfo('get_placement_infos', function(data){
                                capacitySetting.placementsHelpData = data
                                capacitySetting.showPlacementsHelp = true
                        })
                    }
                },
                validateInput: function(clusterInfo, imageNameValue) {
                    //Validate input data.
                    if (clusterInfo.placement == null || clusterInfo.placement.length === 0) {
                        globalNotificationBanner.error = "Placement is not specified"
                        return false
                    }

                    //Validate spiffe_id not modified by user
                    if ('spiffe_id' in clusterInfo.configs && clusterInfo.configs['spiffe_id'] != this.spiffeId){
                        globalNotificationBanner.error = "spiffe id cannot be modified by user"
                        return false
                    }

                    if (imageNameValue.startsWith('cmp_base')){
                        if (!('pinfo_role' in clusterInfo.configs && clusterInfo.configs['pinfo_role']==='cmp_base')){
                            globalNotificationBanner.error = "cmp_base image must have pinfo_role set to cmp_base"
                            return false
                        }

                    }
                    else{
                        if ('pinfo_role' in clusterInfo.configs && clusterInfo.configs['pinfo_role']==='cmp_base'){
                            globalNotificationBanner.error = "Non cmp_base image cannot have pinfo_role set to cmp_base"
                            return false
                        }
                    }

                    if (clusterInfo.cellName  === "aws-us-east-2" && clusterInfo.hostType.startsWith('Compute')){
                         globalNotificationBanner.error = "compute hosts (c3) are not available. Use EbsCompute instead"
                         return false
                    }

                    if (imageNameValue === 'cmp_base' && clusterInfo.hostType.startsWith('EbsCompute')){
                        globalNotificationBanner.error = "EbsCompute  instance must use ebs AMI. Try cmp_base-ebs"
                        return false
                    }

                    return true
                },
                sendRequest: function(clusterInfo) {
                    $.ajax({
                        type: 'POST',
                        url: '/env/{{ env.envName }}/{{ env.stageName }}/config/cluster/config/',
                        data: JSON.stringify(clusterInfo),
                        dataType: "json",
                        beforeSend: function(xhr, settings) {
                            var csrftoken = getCookie('csrftoken')
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);

                        },
                        success: function(data) {
                            globalNotificationBanner.info = "Request sent successfully"
                        },
                        error: function(data) {
                            globalNotificationBanner.error = ["Request Error: ", data.status, data.statusText, data.responseText].join(' ');
                        }
                    });
                },
                securityZoneHelpClick:function(){
                    if (this.showSecurityZoneHelp){
                        this.showSecurityZoneHelp = false
                    }
                    else{
                        this.getHelpInfo('get_security_zone_info', function(data){
                                capacitySetting.securityZoneHelpData = data
                                capacitySetting.showSecurityZoneHelp = true
                        })
                    }
                },
                selectpublicip: function(value){
                    this.assignPublicIP = value
                    if (this.inAdvanced){
                        this.placements = placements.getFullList(this.assignPublicIP, currentPlacements)
                    }
                    else{
                        this.placements = placements.getSimpleList(this.assignPublicIP, currentPlacements)
                    }

                },
                updateAwsRole:function(value){
                    this.awsRole = value
                },
                updateCapacity: function() {
                    // It's really just update cluster info config without capacity
                    //Create the default capacity. The input here aligns to the Rodimus new cluster
                    var clusterInfo = {};
                    clusterInfo['provider'] = this.currentProvider;
                    clusterInfo['cellName'] = this.currentCell;
                    clusterInfo['baseImageId'] = this.baseImageValue;
                    clusterInfo['hostType'] = this.selectedHostTypeValue;
                    clusterInfo['securityZone'] = this.selectedSecurityZoneValue;
                    clusterInfo['placement'] = this.selectedPlacements.join(',');
                    clusterInfo['configs'] = this.allUserData.reduce(function(map, obj) {
                        map[obj.name] = obj.value;
                        return map
                    }, {})
                    if (!this.showCmpGroup && 'cmp_group' in currentCluster.configs){
                        //Unless showcmpgroup is set, cmp_group is set back
                        clusterInfo['configs']['cmp_group'] = currentCluster.configs['cmp_group']
                    }
                    if (this.assignPublicIP){
                        clusterInfo.configs['assign_public_ip'] = true
                    }
                    else{
                        clusterInfo.configs['assign_public_ip'] = false
                    }
                    if (!this.inAdvanced){
                        clusterInfo.configs['aws_role'] = this.awsRole
                    }

                    if (this.imageNameValue.startsWith('cmp_base')){
                        //cmp_base must have cmp_group set.
                        if (!('cmp_group' in clusterInfo['configs'])||clusterInfo['configs']['cmp_group'] === undefined){
                            clusterInfo['configs']['cmp_group'] = info.defaultCMPConfigs['cmp_group']
                        }
                    }
                    else{
                       //non_cmp_base must have cmp_group cleared if it has
                       if ('cmp_group' in clusterInfo['configs']){
                           delete clusterInfo['configs']['cmp_group']
                       }
                    }

                    if (this.validateInput(clusterInfo, this.imageNameValue)) {
                        //Send request
                        this.sendRequest(clusterInfo);
                    }
                },
                clickDialog: function(value) {
                    if (value) {
                        this.updateCapacity();
                    }
                }
            },
            watch: {
                placements: function(){
                    //Schedule this to nextTick that calls after next DOM refresh
                    //as JQuery chosen call must happen after DOM updates finished
                    Vue.nextTick(function(){
                        $(".chosen-select").trigger("chosen:updated")
                    })
                }
            }

        });

        var replaceProgressPanel = new Vue({
             el: "#replaceProgressPanel",
             data: {
                 "show": currentCluster.state != 'NORMAL',
                 "state":  currentCluster.state
             }
        });

        var activeClusterReplaceGraph = new Vue({
             el: "#activeClusterReplaceGraph",
             data: {
                 "show": currentCluster.state != 'NORMAL'
             }
        });

        var sidebar = new Vue({
            el: "#side-panel",
            data: {
                noCluster: !(env.clusterName || $.inArray(env.envName + "-" + env.stageName, groups) >= 0),
                settingText: 'Advanced Settings',
                clusterState: currentCluster.state
            },
            methods: {
                    sendClusterActionRequest: function(action_url){
                        $.ajax({
                            type: 'POST',
                            url: '/env/{{ env.envName }}/{{ env.stageName }}/'+action_url+"/",
                            data: "",
                            dataType: "json",
                            beforeSend: function(xhr, settings) {
                                var csrftoken = getCookie('csrftoken')
                                xhr.setRequestHeader("X-CSRFToken", csrftoken);

                            },
                            success: function (data) {
                                globalNotificationBanner.info = "Replacement request sent successfully"
                                window.location.href=window.location.href
                            },
                            error: function (data) {
                                globalNotificationBanner.error = ["Request Error: ", data.status, data.statusText, data.responseText].join(' ');
                            }
                        });
                    },
                    replaceCluster: function(){
                        this.sendClusterActionRequest('enable_replacement')
                    },
                    cancelReplaceCluster:function(){
                        this.sendClusterActionRequest('cancel_replacement')
                    },
                    pauseReplaceCluster:function(){
                        this.sendClusterActionRequest('pause_replacement')
                    },
                    resumeReplaceCluster:function(){
                        this.sendClusterActionRequest('resume_replacement')
                    },
                    clusterAction: function(confirmedAction){
                        //Check if action is a confirm action
                        if (confirmedAction.value){
                            if (confirmedAction.action === "replace"){
                                this.replaceCluster()
                            }
                            else if (confirmedAction.action === 'cancel'){
                                this.cancelReplaceCluster()
                            }
                            else if (confirmedAction.action === 'resume'){
                                this.resumeReplaceCluster()
                            }
                            else if (confirmedAction.action === 'pause'){
                                this.pauseReplaceCluster()
                            }
                            else{
                                globalNotificationBanner.error = "Unrecongized action "+confirmedAction.action
                            }
                        }
                    },
                buttonClick: function() {
                    capacitySetting.inAdvanced = !capacitySetting.inAdvanced
                    if (capacitySetting.inAdvanced) {
                        this.settingText = 'Basic Settings'
                        capacitySetting.placements = placements.getFullList(capacitySetting.assignPublicIP, currentPlacements)
                    } else {
                        this.settingText = 'Advanced Settings'
                        capacitySetting.placements = placements.getSimpleList(capacitySetting.assignPublicIP, currentPlacements)
                    }
                }
            }
        });

        $(document).ready(function() {
                $(".chosen-select").chosen({
                        "width": "100%"
                    })
                    .change(function() {
                        capacitySetting.selectedPlacements = $('.chosen-select').val()
                    });

           if(showReplaceAlert) {
                // include this tmpl, meaning a cluster replace is going-on, need to check its progress
                // update every 1 min, and execute now
                function setIntervalAndExecute(fn, t) {
                    fn();
                    return(setInterval(fn, t));
                }
                var replaceStartTime = new Date().getTime();
                var replaceProgressInterval = setIntervalAndExecute(function() {
                    if(new Date().getTime() - replaceStartTime > 3600000) {  // if more than 60 mins, clear it
                        console.log('cleared time interval');
                        clearInterval(replaceProgressInterval);
                    }
                    $('#activeClusterReplaceId').load(
                            '/env/{{ env.envName }}/{{ env.stageName }}/get_replacement_progress/'
                    );
                }, 60000);  // request every 1 min

                $.get('/env/{{ env.envName }}/{{ env.stageName }}/get_replacement_details/', function(event_details) {
                    var startTime = event_details['start_time'];
                    console.log('startTime:', startTime);
                    var graphStartTime = new Date().getTime();
                    var graphProgressInterval = setIntervalAndExecute(function() {

                        if(new Date().getTime() - graphStartTime > 3600000) {  // if more than 60 mins, clear it
                            console.log('cleared time interval');
                            clearInterval(graphProgressInterval);
                        }

                        $.get('/env/{{ env.envName }}/{{ env.stageName }}/replacement/scaling_activities/', function(response){
                                    response = response.filter(function(v) {
                                        var timestamp = v['scalingTime'];
                                        return parseInt(timestamp) - parseInt(startTime) > 0;
                                    });
                                    var raw_data = normalizeGraphData(response);
                                    accessibility(raw_data[0], raw_data[1][0], raw_data[1][1]);
                            });
                    }, 120000);  // request every 2 min
                });

           }

        });
    }
    else{
        globalNotificationBanner.error = "Cannot find the cluster"
    }

</script>
{% endblock %}
