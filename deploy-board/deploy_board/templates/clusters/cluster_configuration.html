{% extends 'environs/env_base.html'%} {% load utils %} {% block breadcrumb-items %}
<ul class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/envs">Environments</a></li>
    <li><a href="/env/{{ env.envName }}/{{ env.stageName }}">{{ env.envName }} ({{ env.stageName }})</a></li>
    <li><a href="/env/{{ env.envName }}/{{ env.stageName }}/config">General Config</a></li>
    <li><a href="/env/{{ env.envName }}/{{ env.stageName }}/config/capacity">Capacity</a></li>
    <li class="active">Cluster Configuration</li>
</ul>
{% endblock %} {% load static %} {% block side-panel-actions %}
<link rel="stylesheet" href="//cdn.jsdelivr.net/chartist.js/latest/chartist.min.css">
<style>
    .ct-series-a .ct-bar {
        stroke: #2a7b86;
    }

    .ct-chart table td {
        text-align: center;
    }
    .chosen-container-single .chosen-single div b {
        background: url("chosen-sprite.png") no-repeat 7px 7px;
    }
    .chosen-container-single .chosen-single {
        padding: 0 0 0 16px;
    }
</style>
<script type="text/javascript" src="//cdn.jsdelivr.net/chartist.js/latest/chartist.min.js"></script>
<script type="text/javascript" src="{% static "js/components/sharedcomponents.js"%}?changedate=2023.01.30"></script>
<script type="text/javascript" src="{% static "js/components/capacitycomponents.js"%}?changedate=2023.01.30"></script>
<script type="text/javascript" src="{% static "js/components/clusterconfigcomponents.js"%}?changedate=2023.08.22"></script>
<script type="text/javascript" src="{% static "js/base-image-utils.js"%}?changedate=2023.01.30"></script>

<div class="panel panel-default" id="side-panel">
    <div class="panel-heading clearfix">
        <h4 class="panel-title pull-left">Capacity</h4>
    </div>
    <div v-if="noCluster" class="row">
        <side-button styleclass="fa fa-cloud" text="Create New Capacity" href="/env/{{ env.envName }}/{{ env.stageName }}/config/newcapacity/" title="Create New Cluster"></side-button>
    </div>
    <div v-if="!noCluster" class="row">
        <side-button-nolink styleclass="fa fa-gears" v-on:click="buttonClick" v-bind:text="settingText" title="Cluster Configuration"></side-button-nolink>
    </div>
    <div v-if="!noCluster" class="row">
        <side-button styleclass="glyphicon glyphicon-time" text="Base Image History" title="Base Image History"
            href="/env/{{ env.envName }}/{{ env.stageName }}/base_images">
        </side-button>
    </div>
    <div v-if="!noCluster" class="row">
        <side-button styleclass="glyphicon glyphicon-refresh" text="Cluster Replacement" title="Cluster Replacement"
            href="/env/{{ env.envName }}/{{ env.stageName }}/cluster_replacements">
        </side-button>
    </div>
</div>
{% endblock %} {% block new-builds-panel %} {% endblock %} {% block new-pred-deploys-panel %} {% endblock %} {% block main %}

<div id="clusterAlert">
    <in-rolling-alert v-show="showReplaceAlert" actionlink="/env/{{ env.envName }}/{{ env.stageName }}/config/cluster/config/"></in-rolling-alert>
</div>
{% include "environs/env_tabs.tmpl" with envTabKind="config/capacity" %}


<div id="mainPanel" class="panel panel-default">
    <panel-heading title="Cluster Settings" target="#envCapacityId" initcollapse="false"></panel-heading>
    <div id="envCapacityId" class="collapse in panel-body" v-on:show.bs.collapse="showcontent" v-on:hide.bs.collapse="hidecontent">
        <div class="container-fluid">
            <form id="clusterConfigFormId" class="form-horizontal" role="form">
                <fieldset id="clusterConfigFieldSetId">
                    <cloudprovider-select v-bind:cloudproviders="providers" v-bind:value="currentProvider" v-show="inAdvanced"></cloudprovider-select>
                    <accounts-select v-bind:accounts="accounts" v-bind:value="currentAccountId" v-bind:disabled="!canChangeAccount"></accounts-select>
                    <cell-select v-bind:cells="cells" v-on:cellchange="cellChange"  v-bind:value="currentCell"></cell-select>
                    <arch-select v-bind:arches="arches" v-on:archchange="archChange"  v-bind:value="currentArch"></arch-select>
                    <baseimage-select v-show="inAdvanced" v-model="pinImage" :pin-image-enabled="pinImageEnabled"
                        :image-names="imageNames" :base-images="baseImages" v-bind:account-owner-id="currentAccountOwnerId"
                        :selected-image-name="imageNameValue" :selected-base-image="baseImageValue"
                        @base-image-change="baseImageChange" @image-name-change="imageNameChange" @help-clicked="baseImageHelpClick" >
                    </baseimage-select>
                    <base-image-help v-show="showBaseImageHelp" v-bind:data="baseImageHelpData"></base-image-help>
                    <hosttype-select label="Host Type" title="Compute Capability of the host" v-model="selectedHostTypeValue" v-bind:selectoptions="hostTypeOptions" selectsearch="true"
                    showhelp="true" v-on:helpclick="hostTypeHelpClick"></hosttype-select>
                    <hostype-help v-show="showHostTypeHelp" v-bind:data="hostTypeHelpData"></hostype-help>
                    <label-select label="Security Zone" title="Security zone to control inbound/outboud traffic" v-model="selectedSecurityZoneValue" v-bind:selectoptions="securityZones"
                    showhelp="true" v-on:helpclick="securityZoneHelpClick"></label-select>
                    <securityzone-help v-show="showSecurityZoneHelp" v-bind:data="securityZoneHelpData"></securityzone-help>
                    <placements-select label="Placements" title="Placements" showsubnettype="true" v-bind:selectoptions="placements" v-bind:assignpublicip="assignPublicIP" v-bind:subnettype="subnetType"
                 showhelp="true" v-on:helpclick="placementsHelpClick" v-on:assignpublicipclick="selectpublicip" v-on:subnetfilterclick="changeSubnetType"></placements-select>
                    <remaining-capacity title="The total remaining subnet capacity of selected placements" v-bind:remainingcapacity="remainingCapacity" v-bind:inadvanced="inAdvanced"></remaining-capacity>
                    <form-warning v-show="showSubnetReplacementAlert" v-bind:alert-text="subnetReplacementWarning"></form-warning>
                    <placements-help v-show="showPlacementsHelp" v-bind:data="placementsHelpData"></placements-help>
                    <stateful-select :statefuloptions="statefulStatusOptions" :value="currentStatefulStatus" @help-clicked="statefulHelpClick" @stateful-change="statefulStatusChange"></stateful-select>
                    <stateful-help v-show="showStatefulHelp"></stateful-help>
                    <div v-if="inAdvanced">
                        <div class="form-group"></div>
                        <div class="form-group">
                            <label class="deployToolTip control-label col-xs-2" data-toggle="tooltip"  title="Customize user data">User data configs:</label>
                            {% if is_pinterest %}
                                <a href={{user_data_config_settings_wiki}} target="_blank"><span class="glyphicon glyphicon-question-sign"></span></a>
                            {% endif %}
                            <div class="pull-right">
                                <add-config-button target="#newConfigModalId"></add-config-button>
                                <aws-config-modal id="newConfigModalId" v-bind:options="availableConfigOptions()" v-on:click="addConfig"></aws-config-modal>
                            </div>
                        </div>
                        <deployservice-warning-banner :deployservicewikiurl="deployServiceWikiUrl" :alluserdata="allUserData"></deployservice-warning-banner>
                        <aws-user-data
                            v-bind:alluserdata="allUserData"
                            v-on:deleteconfig="deleteConfig"
                            v-on:change="configChange"
                            v-bind:inadvanced="inAdvanced"
                            v-bind:showcmpgroup="showCmpGroup"
                            v-bind:hierapaths="hieraPaths"
                            v-bind:puppetrepository="puppetRepository"
                        />
                    </div>
                </fieldset>
            </form>
        </div>
    </div>
    <modal v-bind:title="confirmDialogTitle" v-bind:id="confirmDialogId" v-on:input="clickDialog">
        <div slot="body">Are you sure to save the changes? <br><br>Please note that the saved settings will only apply for newly launched hosts. If you have existing hosts in your cluster, you can replace your cluster to perform a rolling replacement of all existing hosts.</div>
    </modal>

    <div class="panel-footer clearfix">
        <div class="pull-right">
            <button id="saveEnvCapacityBtnId" class="btn btn-primary" v-bind:disabled="!canSaveCapacity" data-target="#updateClusterSettings" data-toggle="modal" data-loading-text="Creating...">
            <span class="glyphicon glyphicon-floppy-save"></span> Save
        </button>
        </div>
    </div>
</div>

<script>
/**
 * Chartist.js plugin that generates visually hidden tables for better accessibility. It's also possible to initialize a Chart with data from an existing table.
 *
 */
/* global Chartist */
(function (window, document, Chartist) {
  'use strict';

  // A simple recursive DOM string builder
  function Element(name, attrs, parent) {
    return {
      elem: function (name, attrs) {
        var e = Element(name, attrs, this);
        this.children.push(e);
        return e;
      },
      children: [],
      name: name,
      _attrs: attrs || {},
      _parent: parent,
      parent: function () {
        return this._parent;
      },
      attrs: function (attrs) {
        this._attrs = attrs;
        return this;
      },
      text: function (text, after) {
        if (after) {
          this._textAfter = text;
        } else {
          this._textBefore = text;
        }
        return this;
      },
      toString: function () {
        var attrs = Object.keys(this._attrs).filter(function (attrName) {
          return this._attrs[attrName] || this._attrs[attrName] === 0;
        }.bind(this)).map(function (attrName) {
          return [attrName, '="', this._attrs[attrName], '"'].join('');
        }.bind(this)).join(' ');

        return ['<', this.name, attrs ? ' ' + attrs : '', '>', this._textBefore].concat(this.children.map(function (child) {
          return child.toString();
        })).concat([this._textAfter, '</', this.name, '>']).join('');
      }
    };
  }

  var defaultOptions = {
    caption: 'A graphical chart',
    seriesHeader: 'Series name',
    valueTransform: Chartist.noop,
    summary: undefined,
    elementId: function () {
      return 'ct-accessibility-table';
    },
    visuallyHiddenStyles: 'position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden;'
  };

  Chartist.plugins = Chartist.plugins || {};

  Chartist.plugins.ctAccessibility = function (options) {
      $('#ct-accessibility-table').remove();

    options = Chartist.extend({}, defaultOptions, options);

    return function ctAccessibility(chart) {
      var elementId = typeof options.elementId === 'function' ? options.elementId() : options.elementId;

      chart.on('created', function (data) {
        var containerElement = data.svg._node.parentNode;

        var previousElement = containerElement.querySelector('#' + elementId);
        if(previousElement) {
          containerElement.removeChild(previousElement);
        }

        // As we are now compensating the SVG graphic with the chart with an accessibility table, we hide it for ARIA
        data.svg.attr({
          'aria-hidden': 'true'
        });

        // Create wrapper element
        var element = Element('div', {
          style: options.visuallyHiddenStyles,
          id: elementId
        });

        // Create table body with caption
        var tBody = element.elem('table', {
          class: 'table table-striped table-condensed table-hover',
          summary: options.summary
        }).elem('tbody');

        var firstRow = tBody.elem('tr');

        if (chart instanceof Chartist.Pie) {
          // For pie charts we have only column headers and one series
          var dataArray = Chartist.getDataArray(chart.data, chart.optionsProvider.getCurrentOptions().reverseData);

          // First render the column headers with our pie chart labels
          chart.data.labels.forEach(function (text) {
            firstRow
              .elem('th', {
                scope: 'col',
                role: 'columnheader'
              })
              .text(text);
          });

          var row = tBody.elem('tr');

          // Add all data fields of our pie chart to the row
          dataArray.forEach(function (dataValue) {
            row.elem('td').text(options.valueTransform(dataValue));
          });

        } else {
          // For line and bar charts we have multiple series and therefore also row headers
         // var normalizedData = Chartist.getDataArray(chart.data, chart.optionsProvider.getCurrentOptions().reverseData);
         var normalizedData = chart.data.series;


          // Add column headers inclusing the series column header for the row headers
          [options.seriesHeader].concat(chart.data.labels).forEach(function (text) {
            firstRow
              .elem('th', {
                scope: 'col',
                role: 'columnheader'
              })
              .text(text);
          });

          // Add all data rows including their row headers
          chart.data.series.forEach(function (series, index) {
            var seriesName = series.name || [index + 1, '. Series'].join('');

            var row = tBody.elem('tr');

            row.elem('th', {
              scope: 'row',
              role: 'rowheader'
            }).text(seriesName);

            normalizedData[index].data.forEach(function (dataValue) {
              row.elem('td').text(options.valueTransform(dataValue));
            });
          });
        }

        // Update invisible table in DOM and update table element with newly created table
        containerElement.appendChild(new DOMParser().parseFromString(element.toString(), 'text/html').getElementById(elementId));
      });
    };
  };

}(window, document, Chartist));


    function timeConverter(UNIX_timestamp) {
        var a = new Date(UNIX_timestamp);
        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        var month = months[a.getMonth()];
        var date = a.getDate();
        var hour = a.getHours();
        var min = a.getMinutes();
        if (min < 10) {
            min = '0' + min;
        }
        if (hour < 10) {
            hour = '0' + hour;
        }
        var time = month + ' ' + date + ', ' + hour + ':' + min;
        return time;
    }

    function normalizeGraphData(activities) {
        var times = {};
        for (var i = activities.length - 1; i >= 0; i--) {
            var scalingTime = activities[i]['scalingTime'];
            if (!times[scalingTime]) {
                times[scalingTime] = [];
            }
            times[scalingTime].push(activities[i]);
        }
        var labels = [], series1 = [], series2 = [];
        for (var time in times) {
            if (times.hasOwnProperty(time)) {
                var isLaunching = false;
                var events = times[time];
                var descriptions = [], event, description;
                var causes = [], cause;
                for (var j = 0; j < events.length; j++) {
                    event = events[j];
                    description = event['description'];
                    cause = event['cause'];
                    causes.push(cause);
                    descriptions.push(description);
                    if (description.indexOf('Launching') >= 0) {
                        isLaunching = true;
                    }
                }
                labels.push(timeConverter(parseInt(time)));
                var tooltip = descriptions.join('<br/>');
                var causeTooltip = causes.join('');
                if (isLaunching) {
                    series1.push({name: tooltip, meta: causeTooltip, value: events.length });
                    series2.push({name: '', meta: '', value: 0 });
                } else {
                    series1.push({name: '', meta: '', value: 0 });
                    series2.push({name: tooltip, meta: causeTooltip, value: events.length });
                }

            }
        }
        return [labels, [series1, series2]];
    }


    function accessibility(labels, series1, series2) {
        var width = 50 * labels.length;
        var chart = new Chartist.Bar('.ct-chart', {
                labels: labels,
                series: [
                    {name: '# hosts launched', data: series1},
                    {name: '# hosts terminated', data: series2}
                ]
            },
            {

                lineSmooth: false,
                chartPadding: {
                    right: 20,
                    left: 10
                },
                width: width,
                height: 200,
                axisX: {
                    labelInterpolationFnc: function (value) {
                        return value;
                    }
                },
                axisY: {
                    onlyInteger: true,
                    label: '# of hosts launched/terminated'
                },
                plugins: [
                    Chartist.plugins.ctAccessibility({
                        seriesHeader: 'timeline',
                        valueTransform: function (data) {
                            return data.name;
                        },
                        visuallyHiddenStyles: 'width: 70%; font-size: 11px; overflow-x: auto; background-color: rgba(0, 0, 0, 0.1); padding: 15px;'
                    })
                ]
            });

        var addedEvents = false;
        chart.on('draw', function() {
          if (!addedEvents) {
            $('.ct-chart').on('mouseover', function(event) {
                var $point = event.target;
                var meta = $point.getAttribute('ct:meta')|| '';
                var tips = meta.split('.').filter(function (v) {
                    return v.trim() != '';
                });
                if(tips.length > 0) {
                    var tooltip = '<ul><li>' + tips.join('.</li><li>') + '</li></ul>';
                    $('#tooltip').html(tooltip);
                    $('#tooltip').show();
                }
            });

            $('.ct-chart').on('mouseout', function() {
                  $('#tooltip').hide();
            });
          }
        });

    }
</script>
<script>
    var info = {{capacity_creation_info | safe}};
    var env = info.environment;
    var currentCluster = info.currentCluster;
    var asgLaunchInfo = currentCluster.asg_info.launchInfo;
    var statefulOptions = info.stateful_options;
    const goldenImage = info.baseImages.find(goldenImageFinder);
    if (currentCluster!=null){
        var currentPlacements = currentCluster.placement.split(',');
        var placements = getDefaultPlacement(info);
        var showReplaceAlert = currentCluster != null && currentCluster.state != "NORMAL";
        var alert = new Vue({
            el: "#clusterAlert",
            data: {
                showReplaceAlert: showReplaceAlert
            }
        });
        const initialAssignPublicIP = currentCluster.configs.assign_public_ip === "true" ;
        const initialCell = currentCluster.cellName;
        var baseImagesSorted = info.baseImages.sort(baseImageSorter);

        if (currentCluster.baseImage != null) {
            ensureCurrentImageIsIncluded(baseImagesSorted, currentCluster.baseImage);
        }

        var readonlyValues = info.readonlyFields.reduce((obj, field) => {
            obj[field] = field in currentCluster.configs ? currentCluster.configs[field] : null
            return obj;
        }, {});

        const hieraPaths = `{{ puppet_hiera_paths }}`;
        const puppetRepository = `{{ puppet_repository }}`;
        const deployServiceWikiUrl = `{{ conflicting_deploy_service_wiki_url }}`;

        var capacitySetting = new Vue({
            el: "#mainPanel",
            data: Object.assign(readonlyValues, {
                allUserData:  Object.keys(currentCluster.configs).map(
                        function(key) {
                            return {
                                name: key,
                                value: currentCluster.configs[key],
                                readonly: info.readonlyFields.indexOf(key) >= 0
                            }
                        }).filter(function(item){return item.name!='assign_public_ip'}),
                assignPublicIP: initialAssignPublicIP,
                awsRole: currentCluster.configs.aws_role,
                capacity: currentCluster.capacity != asgLaunchInfo.minSize ? asgLaunchInfo.minSize : currentCluster.capacity,
                useLaunchTemplate: currentCluster.useLaunchTemplate != null ? currentCluster.useLaunchTemplate : info.defaultUseLaunchTemplate,
                baseImages: mapBaseImagesToOptions(baseImagesSorted),
                baseImageValue: currentCluster.baseImageId,
                pinImage: getPinImageValue(goldenImage, currentCluster.autoUpdateBaseImage),
                pinImageEnabled: isPinImageEnabled(goldenImage),
                confirmDialogTitle: "Update Cluster Settings",
                confirmDialogId: "updateClusterSettings",
                currentProvider: currentCluster.provider,
                currentAccountId: currentCluster.accountId,
                currentAccountOwnerId: getAccountOwnerId(this.currentAccountId),
                currentCell: currentCluster.cellName,
                currentArch: currentCluster.archName,
                currentStatefulStatus: currentCluster.statefulStatus,
                hostTypeOptions: info.hostTypes.map(function(item, idx) {
                    return {
                        value: item.id,
                        text: item.provider_name + " (" + item.core + " cores, " + item.mem + " GB, " + item.storage + ", " + item.network + ", " + item.provider + ": " + item.abstract_name + ")",
                        isSelected: item.id === currentCluster.hostType,
                        isDisabled: item.retired
                    }
                }),
                imageNameValue: currentCluster.baseImageName,
                imageNames: mapImageNameToOptions(info.baseImageNames),
                inAdvanced: false,
                initialCell: this.currentCell,
                placements: this.inAdvanced ?
                    placements.getFullList(initialAssignPublicIP, currentPlacements) :
                    placements.getSimpleList(initialAssignPublicIP, currentPlacements),
                accounts: info.accounts?.map(account => ({
                    value: account.id,
                    text: `${account.ownerId} / ${account.name} / ${account.description}`,
                    isSelected: account.id === currentCluster.accountId
                })),
                providers: info.providerList.map(function(o) {
                    return {
                        value: o,
                        text: o
                    }
                }),
                statefulStatusOptions: statefulOptions.map(function(o) {
                    return {
                        value: o,
                        text: o
                    }
                }),
                cells: info.cells.map(
                    function (item) {
                        return {
                            value: item.name,
                            text: item.name,
                            isSelected: item.name == currentCluster.cellName
                        }
                    }),
                arches: info.arches.map(
                    function (item) {
                        return {
                            value: item.name,
                            text: item.name,
                            isSelected: item.name == currentCluster.archName
                        }
                    }),
                terminateLimit: currentCluster.terminateLimit,
                securityZones: info.securityZones.map(function(item) {
                    return {
                        value: item.abstract_name,
                        text: item.abstract_name,
                        isSelected: item.abstract_name === currentCluster.securityZone
                    }
                }),
                selectedHostTypeValue: currentCluster.hostType,
                selectedSecurityZoneValue: currentCluster.securityZone,
                selectedPlacements: currentPlacements,
                showBaseImageHelp: false,
                baseImageHelpData: [],
                showHostTypeHelp: false,
                hostTypeHelpData:[],
                showSecurityZoneHelp: false,
                securityZoneHelpData: [],
                showPlacementsHelp: false,
                placementsHelpData: [],
                canChangeAccount: false,
                canSaveCapacity: !showReplaceAlert,
                showCmpGroup: Boolean(getUrlParameter("showcmpgroup")),
                subnetType: initialAssignPublicIP ? "public" : "private",
                showSubnetReplacementAlert: false,
                subnetReplacementWarning: "Cluster can't have a mix of public and private subnets. Saving this config will remove existing subnets.",
                remainingCapacity: this.placements != null ? getRemainingCapacity(info.placements, currentPlacements) : Infinity,
                showStatefulHelp: false,
                puppetRepository,
                hieraPaths,
                deployServiceWikiUrl,
            }),
            methods: {
                addConfig: function(config) {
                    var filter = this.allUserData.filter(function(data) {
                        return data.name === config.name
                    })
                    if (filter.length == 0) {
                        this.allUserData.push(config)
                    } else {
                        filter[0].value = config.value
                    }
                },
                availableConfigOptions: function() {
                    var options = Object.keys(info.configList).map(function(key) {
                        return {
                            name: key,
                            text: key,
                            default: info.configList[key]
                        }
                    }).filter(function(item){return item.name!='assign_public_ip'})
                    if (this.inAdvanced){
                        return options;
                    }
                    else{
                        return options.filter(function(item){return !item.name.startsWith("pinfo_") && item.name!="cmp_group" });
                    }
                },
                configChange: function(input){
                    this.allUserData = this.allUserData.map(function(item){
                        if (item.name===input.name){
                            return input
                        }
                        else{
                            return item
                        }
                    })
                },
                baseImageHelpClick: function(){
                    if (this.showBaseImageHelp){
                        this.showBaseImageHelp = false;
                    }
                    else{
                        this.getHelpInfo('get_base_image_info/' + this.imageNameValue, function(data){
                            data = data.map(function(item){
                                item.publish_date=new Date(item.publish_date)
                                if (item.description == null || item.description.length==0){
                                    item.description = "None"
                                }
                                return item
                            })
                            capacitySetting.baseImageHelpData = data
                            capacitySetting.showBaseImageHelp = true
                        }, {cell: capacitySetting.currentCell})
                    }
                },
                baseImageChange: function(value) {
                    this.baseImageValue = value
                },
                deleteConfig: function(name) {
                    if (name == 'root_volume_type') {
                        globalNotificationBanner.info = "On deleting this configuration and saving it, the root volume type will be set to default value, which is gp3 currently"
                    }
                    this.allUserData = this.allUserData.filter(function(config) {
                        return config.name != name
                    })
                },
                getHelpInfo: function(path, onSuccess, params){
                    const searchParams = new URLSearchParams(params);
                    const seachParamStr = params != null ? `?${searchParams}` : '';
                    $.ajax({
                        type: 'GET',
                        url: `${location.protocol}//${location.host}/clouds/${path}/${seachParamStr}`,
                        dataType: "json",
                        beforeSend: function(xhr, settings) {
                            var csrftoken = getCookie('csrftoken')
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);

                        },
                        success: function(data){
                            onSuccess(data)
                        },
                        error: function(data) {
                            globalNotificationBanner.error = ["Request Error: ", data.status, data.statusText, data.responseText].join(' ');
                        }
                    });
                },
                hostTypeHelpClick: function(){
                    if (this.showHostTypeHelp){
                        this.showHostTypeHelp = false;
                    }
                    else{
                        this.getHelpInfo('get_host_types/' + capacitySetting.currentArch, function(data){
                                capacitySetting.hostTypeHelpData = data
                                capacitySetting.showHostTypeHelp = true
                            }, {cell: capacitySetting.currentCell})
                    }
                },
                cellChange: function(value) {
                    capacitySetting.currentCell = value;
                    // grab all the image names
                    var scope = this;
                    var provider = capacitySetting.currentProvider;
                    var arch = capacitySetting.currentArch;
                    var cell = value;
                    $.ajax({
                        type: 'GET',
                        url: location.protocol + '//' + location.host + '/clouds/image_names/' + provider + '/' + cell + '/' + arch,
                        dataType: "json",
                        beforeSend: function (xhr) {
                            var csrftoken = getCookie('csrftoken');
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);
                        },
                        success: function (data) {
                            capacitySetting.imageNames = mapImageNameToOptions(data);
                            capacitySetting.imageNameValue = data[0];
                            scope.imageNameChange(data[0]);
                        },
                        error: function (data) {
                            globalNotificationBanner.error = data
                        }
                    });

                     // grab all security zone for this cell
                    const securityZonesUrl =
                        `${location.protocol}//${location.host}/clouds/securityzones/${provider}/${cell}` +
                        `?accountId=${this.currentAccountId}`
                    $.ajax({
                        type: 'GET',
                        url: securityZonesUrl,
                        dataType: "json",
                        beforeSend: function (xhr) {
                            var csrftoken = getCookie('csrftoken');
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);
                        },
                        success: function (data) {
                            capacitySetting.securityZones = data?.map(
                                function (item) {
                                    return {
                                        value: item.abstract_name,
                                        text: item.abstract_name,
                                        isSelected: item.id === data[0].id
                                    }
                                }) ?? [];
                            capacitySetting.selectedSecurityZoneValue = data[0]?.abstract_name;
                        },
                        error: function (data) {
                            globalNotificationBanner.error = data
                        }
                    });

                    // grab all placement for this cell
                    const placementsUrl =
                        `${location.protocol}//${location.host}/clouds/placements/${provider}/${cell}` +
                        `?accountId=${this.currentAccountId}`
                    $.ajax({
                        type: 'GET',
                        url: placementsUrl,
                        dataType: "json",
                        beforeSend: function (xhr) {
                            var csrftoken = getCookie('csrftoken');
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);
                        },
                        success: function (data) {
                            var placements = data ? getDefaultPlacement({'placements': data}) : null;
                            capacitySetting.placements =
                                placements ? placements.getFullList(false, cell == initialCell ? currentPlacements : null) : null;
                        },
                        error: function (data) {
                            globalNotificationBanner.error = data
                        }
                    })
                },
                archChange: function(value) {
                    capacitySetting.archValue = value;
                    capacitySetting.currentArch = value;
                    // grab all the image names
                    var scope = this;
                    var provider = capacitySetting.currentProvider;
                    var cell = capacitySetting.currentCell;
                    var arch = value;
                    $.ajax({
                        type: 'GET',
                        url: location.protocol + '//' + location.host + '/clouds/image_names/' + provider + '/' + cell + '/' + arch,
                        dataType: "json",
                        beforeSend: function (xhr) {
                            var csrftoken = getCookie('csrftoken');
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);
                        },
                        success: function (data) {
                            let imageName = data[0];
                            capacitySetting.imageNames = mapImageNameToOptions(data);
                            info.baseImageNames = data;
                            capacitySetting.imageNameValue = imageName;
                            scope.imageNameChange(imageName);
                        },
                        error: function (data) {
                            globalNotificationBanner.error = data
                        }
                    });
                    // grab all the host types
                    $.ajax({
                        type: 'GET',
                        url: location.protocol + '//' + location.host + '/clouds/get_host_types/' + arch,
                        dataType: "json",
                        beforeSend: function (xhr) {
                            var csrftoken = getCookie('csrftoken');
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);
                        },
                        success: function (data) {
                            capacitySetting.hostTypeOptions = data.map(
                                    function (item) {
                                        return {
                                            value: item.id,
                                            text: item.provider_name + " (" + item.core + " cores, " + item.mem + " GB, " + item.storage + ", " + item.network + ", " + item.provider + ": " + item.abstract_name + ")",
                                            isSelected: item.id === data[0],
                                            isDisabled: item.retired
                                        }
                                    });
                            capacitySetting.selectedHostTypeValue = data[0].id;
                            //Schedule this to nextTick that calls after next DOM refresh
                            //as JQuery chosen call must happen after DOM updates finished
                            Vue.nextTick(function(){
                                $(".single-select-search").trigger("chosen:updated")
                            })
                        },
                        error: function (data) {
                            globalNotificationBanner.error = data
                        }
                    });
                },
                imageNameChange: function(value) {
                    var cell = capacitySetting.currentCell;
                    capacitySetting.imageNameValue = value;
                    //Grab all images for this image name
                    $.ajax({
                        type: 'GET',
                        url: location.protocol + '//' + location.host + '/clouds/get_base_images/' + value + '?cell=' + cell,
                        dataType: "json",
                        beforeSend: function(xhr, settings) {
                            var csrftoken = getCookie('csrftoken')
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);
                        },
                        success: function(baseImages) {
                            const baseImagesSorted = baseImages.sort(baseImageSorter);
                            const goldenImage = baseImages.find(goldenImageFinder);

                            var defaultImageId;
                            if (currentCluster.baseImageName == value && currentCluster.cellName == cell && capacitySetting.pinImage) {
                                ensureCurrentImageIsIncluded(baseImagesSorted, currentCluster.baseImage);
                                defaultImageId = currentCluster.baseImageId;
                            } else{
                                defaultImageId = goldenImage ? goldenImage.id : getDefaultBaseImageId(baseImagesSorted);
                            }

                            capacitySetting.baseImages = mapBaseImagesToOptions(baseImagesSorted);
                            capacitySetting.baseImageValue = defaultImageId;
                            capacitySetting.pinImage = getPinImageValue(goldenImage, currentCluster.autoUpdateBaseImage)
                            capacitySetting.pinImageEnabled = isPinImageEnabled(goldenImage);
                        },
                        error: function(data) {
                            globalNotificationBanner.error = data
                        }
                    });
                },
                updateImageNameForEbsHost: function () {
                    var cell = capacitySetting.currentCell;
                    var scope = this;
                    var provider = capacitySetting.currentProvider;
                    value = '{{ default_cmp_image }}';
                    const selectedHostTypeObject = capacityCreationInfo.hostTypes.find(hostType => hostType.id === this.selectedHostTypeValue);
                    if (selectedHostTypeObject.abstract_name.startsWith('EbsCompute')) {
                        capacitySetting.imageNameValue = value;
                        capacitySetting.imageNames = mapImageNameToOptions(info.baseImageNames);
                        scope.imageNameChange(value);
                    }
                },
                placementsHelpClick: function(){
                    if (this.showPlacementsHelp){
                        this.showPlacementsHelp = false
                    }
                    else{
                        this.getHelpInfo('get_placement_infos', function(data){
                                capacitySetting.placementsHelpData = data
                                capacitySetting.showPlacementsHelp = true
                        })
                    }
                },
                validateInput: function(clusterInfo, imageNameValue) {
                    //Validate input data.
                    if (clusterInfo.placement == null || clusterInfo.placement.length === 0) {
                        globalNotificationBanner.error = "Placement is not specified"
                        return false
                    }

                    for (var i in info.readonlyFields) {
                        var readonlyField = info.readonlyFields[i];
                        if (readonlyField in clusterInfo.configs && clusterInfo.configs[readonlyField] != this[readonlyField]){
                            globalNotificationBanner.error = readonlyField + " cannot be modified by user"
                            return false
                        }
                    }

                    if (imageNameValue.startsWith('cmp_base')){
                        if (!('pinfo_role' in clusterInfo.configs && clusterInfo.configs['pinfo_role']==='cmp_base')){
                            globalNotificationBanner.error = "cmp_base image must have pinfo_role set to cmp_base"
                            return false
                        }
                    }
                    else{
                        if ('pinfo_role' in clusterInfo.configs && clusterInfo.configs['pinfo_role']==='cmp_base'){
                            globalNotificationBanner.error = "Non cmp_base image cannot have pinfo_role set to cmp_base"
                            return false
                        }
                    }

                    if (clusterInfo.cellName  === "aws-us-east-2" && clusterInfo.hostType.startsWith('Compute')){
                         globalNotificationBanner.error = "compute hosts (c3) are not available. Use EbsCompute instead"
                         return false
                    }

                    if (imageNameValue === 'cmp_base' && clusterInfo.hostType.startsWith('EbsCompute')){
                        globalNotificationBanner.error = "EbsCompute  instance must use ebs AMI. Try cmp_base-ebs"
                        return false
                    }

                    if ('root_volume_type' in clusterInfo.configs && !(["gp2", "gp3"].includes(clusterInfo.configs['root_volume_type']))) {
                        globalNotificationBanner.error = "At this time only gp2 and gp3 root volume types are supported"
                        return false
                    }

                    return true
                },
                sendRequest: function(clusterInfo) {
                    $.ajax({
                        type: 'POST',
                        url: '/env/{{ env.envName }}/{{ env.stageName }}/config/cluster/config/',
                        data: JSON.stringify(clusterInfo),
                        dataType: "json",
                        beforeSend: function(xhr, settings) {
                            var csrftoken = getCookie('csrftoken')
                            xhr.setRequestHeader("X-CSRFToken", csrftoken);

                        },
                        success: function(data) {
                            globalNotificationBanner.info = "Request sent successfully"
                        },
                        error: function(data) {
                            globalNotificationBanner.error = ["Request Error: ", data.status, data.statusText, data.responseText].join(' ');
                        }
                    });
                },
                securityZoneHelpClick:function(){
                    if (this.showSecurityZoneHelp){
                        this.showSecurityZoneHelp = false
                    }
                    else{
                        this.getHelpInfo('get_security_zone_info', function(data){
                                capacitySetting.securityZoneHelpData = data
                                capacitySetting.showSecurityZoneHelp = true
                        })
                    }
                },
                selectpublicip: function(value){
                    this.assignPublicIP = value
                    if (this.assignPublicIP && this.subnetType == 'private' ||
                        !this.assignPublicIP && this.subnetType == 'public') {
                        globalNotificationBanner.error =
                            `Warning: You ${this.assignPublicIP ? 'selected' :'unselected'} 'Assign Public IP' for ${this.subnetType} subnet type. ` +
                            `Please double check if this is desired. If you DO require this configuration, please report your scenario to the Teletraan team.`
                    }
                    else {
                        globalNotificationBanner.error = ""
                    }
                },
                changeSubnetType: function(value) {
                    this.subnetType = value
                    var showPublicSubnets = value == 'public' ? true : false
                    this.assignPublicIP = showPublicSubnets
                    this.showSubnetReplacementAlert = initialAssignPublicIP != showPublicSubnets
                    if (this.inAdvanced){
                        this.placements = placements.getFullList(showPublicSubnets, this.selectedPlacements)
                    }
                    else{
                        this.placements = placements.getSimpleList(showPublicSubnets, this.selectedPlacements)
                    }
                },
                updateAwsRole:function(value){
                    this.awsRole = value
                },
                updateCapacity: function() {
                    // It's really just update cluster info config without capacity
                    //Create the default capacity. The input here aligns to the Rodimus new cluster
                    var clusterInfo = {};
                    clusterInfo['accountId'] = this.currentAccoundId;
                    clusterInfo['capacity'] = this.capacity;
                    clusterInfo['provider'] = this.currentProvider;
                    clusterInfo['cellName'] = this.currentCell;
                    clusterInfo['archName'] = this.currentArch;
                    clusterInfo['hostType'] = this.selectedHostTypeValue;
                    clusterInfo['securityZone'] = this.selectedSecurityZoneValue;
                    clusterInfo['useLaunchTemplate'] = this.useLaunchTemplate;
                    clusterInfo['placement'] = this.selectedPlacements.join(',');
                    clusterInfo['statefulStatus'] = this.currentStatefulStatus;
                    clusterInfo['configs'] = this.allUserData.reduce(function(map, obj) {
                        map[obj.name] = obj.value;
                        return map
                    }, {})
                    if (!this.showCmpGroup && 'cmp_group' in currentCluster.configs){
                        //Unless showcmpgroup is set, cmp_group is set back
                        clusterInfo['configs']['cmp_group'] = currentCluster.configs['cmp_group']
                    }
                    if (this.assignPublicIP){
                        clusterInfo.configs['assign_public_ip'] = true
                    }
                    else{
                        clusterInfo.configs['assign_public_ip'] = false
                    }
                    if (!this.inAdvanced){
                        clusterInfo.configs['aws_role'] = this.awsRole
                    }

                    if (!this.pinImage) {
                        clusterInfo['autoUpdateBaseImage'] = true;
                        clusterInfo['baseImageName'] = this.imageNameValue;
                    } else {
                        clusterInfo['autoUpdateBaseImage'] = false;
                        clusterInfo['baseImageId'] = this.baseImageValue;
                    }

                    if (this.imageNameValue.startsWith('cmp_base')){
                        //cmp_base must have cmp_group set.
                        if (!('cmp_group' in clusterInfo['configs'])||clusterInfo['configs']['cmp_group'] === undefined){
                            clusterInfo['configs']['cmp_group'] = info.defaultCMPConfigs['cmp_group']
                        }
                    }
                    else{
                       //non_cmp_base must have cmp_group cleared if it has
                       if ('cmp_group' in clusterInfo['configs']){
                           delete clusterInfo['configs']['cmp_group']
                       }
                    }

                    if (this.validateInput(clusterInfo, this.imageNameValue)) {
                        //Send request
                        this.sendRequest(clusterInfo);
                    }
                },
                clickDialog: function(value) {
                    if (value) {
                        this.updateCapacity();
                    }
                },
                statefulHelpClick: function(value) {
                    if (this.showStatefulHelp) {
                        this.showStatefulHelp = false
                    } else {
                        capacitySetting.showStatefulHelp = true
                    }
                },
                statefulStatusChange: function(value) {
                    this.currentStatefulStatus = value
                },
            },
            watch: {
                placements: function(){
                    //Schedule this to nextTick that calls after next DOM refresh
                    //as JQuery chosen call must happen after DOM updates finished
                    Vue.nextTick(function(){
                        $(".chosen-select").trigger("chosen:updated")
                    })
                },
                selectedPlacements: function() {
                    this.remainingCapacity = getRemainingCapacity(info.placements, this.selectedPlacements);
                }
            }
        });

        var sidebar = new Vue({
            el: "#side-panel",
            data: {
                noCluster: !(env.clusterName || $.inArray(env.envName + "-" + env.stageName, groups) >= 0),
                settingText: 'Advanced Settings',
                clusterState: currentCluster.state
            },
            methods: {
                    sendClusterActionRequest: function(action_url){
                        $.ajax({
                            type: 'POST',
                            url: '/env/{{ env.envName }}/{{ env.stageName }}/'+action_url+"/",
                            data: "",
                            dataType: "json",
                            beforeSend: function(xhr, settings) {
                                var csrftoken = getCookie('csrftoken')
                                xhr.setRequestHeader("X-CSRFToken", csrftoken);

                            },
                            success: function (data) {
                                globalNotificationBanner.info = "Replacement request sent successfully"
                                window.location.href=window.location.href
                            },
                            error: function (data) {
                                globalNotificationBanner.error = ["Request Error: ", data.status, data.statusText, data.responseText].join(' ');
                            }
                        });
                    },
                buttonClick: function() {
                    capacitySetting.inAdvanced = !capacitySetting.inAdvanced
                    if (capacitySetting.inAdvanced) {
                        this.settingText = 'Basic Settings'
                        capacitySetting.placements = placements.getFullList(capacitySetting.assignPublicIP, currentPlacements)
                    } else {
                        this.settingText = 'Advanced Settings'
                        capacitySetting.placements = placements.getSimpleList(capacitySetting.assignPublicIP, currentPlacements)
                    }
                }
            }
        });

        $(document).ready(function() {
            $('.single-select-search').chosen({
                "width": "100%"
            }).change(function() {
                capacitySetting.selectedHostTypeValue = $('.single-select-search').val()
            });

            $(".chosen-select").chosen({
                    "width": "100%"
                })
                .change(function() {
                    capacitySetting.selectedPlacements = $('.chosen-select').val()
                });

           var selectedHostTypeObject = info.hostTypes.find(hostType => hostType.id === capacitySetting.selectedHostTypeValue);
           var hostTypeRoadmapLink = "{{ host_type_roadmap_link }}"

            if (selectedHostTypeObject.blessed_status === "DECOMMISSIONING" || selectedHostTypeObject.retired === true) {
                globalNotificationBanner.error = "This cluster is currently using an unblessed Instance Type. Please refer to " + hostTypeRoadmapLink + " for the recommended Instance Type.";
            }
        });
    } else {
        globalNotificationBanner.error = "Cannot find the cluster"
    }

</script>
{% endblock %}
